/*
AuditBoard Developer Portal API Documentation

External API reference documentation.

API version: 23.8.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package auditboard

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// TaskItemsAPIService TaskItemsAPI service
type TaskItemsAPIService service

type ApiTaskItemsGetRequest struct {
	ctx context.Context
	ApiService *TaskItemsAPIService
	include *[]string
}

// Possible sideloaded relationships
func (r ApiTaskItemsGetRequest) Include(include []string) ApiTaskItemsGetRequest {
	r.include = &include
	return r
}

func (r ApiTaskItemsGetRequest) Execute() (*TaskItemsGet200Response, *http.Response, error) {
	return r.ApiService.TaskItemsGetExecute(r)
}

/*
TaskItemsGet Method for TaskItemsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTaskItemsGetRequest
*/
func (a *TaskItemsAPIService) TaskItemsGet(ctx context.Context) ApiTaskItemsGetRequest {
	return ApiTaskItemsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaskItemsGet200Response
func (a *TaskItemsAPIService) TaskItemsGetExecute(r ApiTaskItemsGetRequest) (*TaskItemsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskItemsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskItemsAPIService.TaskItemsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task_items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTaskItemsImportJsonPostRequest struct {
	ctx context.Context
	ApiService *TaskItemsAPIService
	taskItemsImportJsonPostRequest *TaskItemsImportJsonPostRequest
}

func (r ApiTaskItemsImportJsonPostRequest) TaskItemsImportJsonPostRequest(taskItemsImportJsonPostRequest TaskItemsImportJsonPostRequest) ApiTaskItemsImportJsonPostRequest {
	r.taskItemsImportJsonPostRequest = &taskItemsImportJsonPostRequest
	return r
}

func (r ApiTaskItemsImportJsonPostRequest) Execute() (*TaskItemsImportJsonPost200Response, *http.Response, error) {
	return r.ApiService.TaskItemsImportJsonPostExecute(r)
}

/*
TaskItemsImportJsonPost Method for TaskItemsImportJsonPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTaskItemsImportJsonPostRequest
*/
func (a *TaskItemsAPIService) TaskItemsImportJsonPost(ctx context.Context) ApiTaskItemsImportJsonPostRequest {
	return ApiTaskItemsImportJsonPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaskItemsImportJsonPost200Response
func (a *TaskItemsAPIService) TaskItemsImportJsonPostExecute(r ApiTaskItemsImportJsonPostRequest) (*TaskItemsImportJsonPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskItemsImportJsonPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskItemsAPIService.TaskItemsImportJsonPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task_items/import/json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taskItemsImportJsonPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTaskItemsPostRequest struct {
	ctx context.Context
	ApiService *TaskItemsAPIService
	taskItemsPostRequest *TaskItemsPostRequest
}

func (r ApiTaskItemsPostRequest) TaskItemsPostRequest(taskItemsPostRequest TaskItemsPostRequest) ApiTaskItemsPostRequest {
	r.taskItemsPostRequest = &taskItemsPostRequest
	return r
}

func (r ApiTaskItemsPostRequest) Execute() (*TaskItemsGet200Response, *http.Response, error) {
	return r.ApiService.TaskItemsPostExecute(r)
}

/*
TaskItemsPost Method for TaskItemsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTaskItemsPostRequest
*/
func (a *TaskItemsAPIService) TaskItemsPost(ctx context.Context) ApiTaskItemsPostRequest {
	return ApiTaskItemsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaskItemsGet200Response
func (a *TaskItemsAPIService) TaskItemsPostExecute(r ApiTaskItemsPostRequest) (*TaskItemsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskItemsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskItemsAPIService.TaskItemsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task_items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taskItemsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTaskItemsTaskItemIdDeleteRequest struct {
	ctx context.Context
	ApiService *TaskItemsAPIService
	taskItemId int64
}

func (r ApiTaskItemsTaskItemIdDeleteRequest) Execute() (*TaskItems, *http.Response, error) {
	return r.ApiService.TaskItemsTaskItemIdDeleteExecute(r)
}

/*
TaskItemsTaskItemIdDelete Method for TaskItemsTaskItemIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskItemId Model id
 @return ApiTaskItemsTaskItemIdDeleteRequest
*/
func (a *TaskItemsAPIService) TaskItemsTaskItemIdDelete(ctx context.Context, taskItemId int64) ApiTaskItemsTaskItemIdDeleteRequest {
	return ApiTaskItemsTaskItemIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		taskItemId: taskItemId,
	}
}

// Execute executes the request
//  @return TaskItems
func (a *TaskItemsAPIService) TaskItemsTaskItemIdDeleteExecute(r ApiTaskItemsTaskItemIdDeleteRequest) (*TaskItems, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskItemsAPIService.TaskItemsTaskItemIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task_items/{task_item_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"task_item_id"+"}", url.PathEscape(parameterValueToString(r.taskItemId, "taskItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTaskItemsTaskItemIdGetRequest struct {
	ctx context.Context
	ApiService *TaskItemsAPIService
	taskItemId int64
	include *[]string
}

// Possible sideloaded relationships
func (r ApiTaskItemsTaskItemIdGetRequest) Include(include []string) ApiTaskItemsTaskItemIdGetRequest {
	r.include = &include
	return r
}

func (r ApiTaskItemsTaskItemIdGetRequest) Execute() (*TaskItems, *http.Response, error) {
	return r.ApiService.TaskItemsTaskItemIdGetExecute(r)
}

/*
TaskItemsTaskItemIdGet Method for TaskItemsTaskItemIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskItemId Model id
 @return ApiTaskItemsTaskItemIdGetRequest
*/
func (a *TaskItemsAPIService) TaskItemsTaskItemIdGet(ctx context.Context, taskItemId int64) ApiTaskItemsTaskItemIdGetRequest {
	return ApiTaskItemsTaskItemIdGetRequest{
		ApiService: a,
		ctx: ctx,
		taskItemId: taskItemId,
	}
}

// Execute executes the request
//  @return TaskItems
func (a *TaskItemsAPIService) TaskItemsTaskItemIdGetExecute(r ApiTaskItemsTaskItemIdGetRequest) (*TaskItems, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskItemsAPIService.TaskItemsTaskItemIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task_items/{task_item_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"task_item_id"+"}", url.PathEscape(parameterValueToString(r.taskItemId, "taskItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTaskItemsTaskItemIdPutRequest struct {
	ctx context.Context
	ApiService *TaskItemsAPIService
	taskItemId int64
	taskItemsPut *TaskItemsPut
}

func (r ApiTaskItemsTaskItemIdPutRequest) TaskItemsPut(taskItemsPut TaskItemsPut) ApiTaskItemsTaskItemIdPutRequest {
	r.taskItemsPut = &taskItemsPut
	return r
}

func (r ApiTaskItemsTaskItemIdPutRequest) Execute() (*TaskItems, *http.Response, error) {
	return r.ApiService.TaskItemsTaskItemIdPutExecute(r)
}

/*
TaskItemsTaskItemIdPut Method for TaskItemsTaskItemIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskItemId Model id
 @return ApiTaskItemsTaskItemIdPutRequest
*/
func (a *TaskItemsAPIService) TaskItemsTaskItemIdPut(ctx context.Context, taskItemId int64) ApiTaskItemsTaskItemIdPutRequest {
	return ApiTaskItemsTaskItemIdPutRequest{
		ApiService: a,
		ctx: ctx,
		taskItemId: taskItemId,
	}
}

// Execute executes the request
//  @return TaskItems
func (a *TaskItemsAPIService) TaskItemsTaskItemIdPutExecute(r ApiTaskItemsTaskItemIdPutRequest) (*TaskItems, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskItemsAPIService.TaskItemsTaskItemIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task_items/{task_item_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"task_item_id"+"}", url.PathEscape(parameterValueToString(r.taskItemId, "taskItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taskItemsPut
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTaskItemsWorkstreamTaskIdCertifyPostRequest struct {
	ctx context.Context
	ApiService *TaskItemsAPIService
	workstreamTaskId int64
}

func (r ApiTaskItemsWorkstreamTaskIdCertifyPostRequest) Execute() (*TaskItemsWorkstreamTaskIdClosePost200Response, *http.Response, error) {
	return r.ApiService.TaskItemsWorkstreamTaskIdCertifyPostExecute(r)
}

/*
TaskItemsWorkstreamTaskIdCertifyPost Method for TaskItemsWorkstreamTaskIdCertifyPost

Submits the workstream task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workstreamTaskId Workstream Task id
 @return ApiTaskItemsWorkstreamTaskIdCertifyPostRequest
*/
func (a *TaskItemsAPIService) TaskItemsWorkstreamTaskIdCertifyPost(ctx context.Context, workstreamTaskId int64) ApiTaskItemsWorkstreamTaskIdCertifyPostRequest {
	return ApiTaskItemsWorkstreamTaskIdCertifyPostRequest{
		ApiService: a,
		ctx: ctx,
		workstreamTaskId: workstreamTaskId,
	}
}

// Execute executes the request
//  @return TaskItemsWorkstreamTaskIdClosePost200Response
func (a *TaskItemsAPIService) TaskItemsWorkstreamTaskIdCertifyPostExecute(r ApiTaskItemsWorkstreamTaskIdCertifyPostRequest) (*TaskItemsWorkstreamTaskIdClosePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskItemsWorkstreamTaskIdClosePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskItemsAPIService.TaskItemsWorkstreamTaskIdCertifyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task_items/{workstream_task_id}/certify"
	localVarPath = strings.Replace(localVarPath, "{"+"workstream_task_id"+"}", url.PathEscape(parameterValueToString(r.workstreamTaskId, "workstreamTaskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTaskItemsWorkstreamTaskIdClosePostRequest struct {
	ctx context.Context
	ApiService *TaskItemsAPIService
	workstreamTaskId int64
	taskItemsWorkstreamTaskIdClosePostRequest *TaskItemsWorkstreamTaskIdClosePostRequest
}

func (r ApiTaskItemsWorkstreamTaskIdClosePostRequest) TaskItemsWorkstreamTaskIdClosePostRequest(taskItemsWorkstreamTaskIdClosePostRequest TaskItemsWorkstreamTaskIdClosePostRequest) ApiTaskItemsWorkstreamTaskIdClosePostRequest {
	r.taskItemsWorkstreamTaskIdClosePostRequest = &taskItemsWorkstreamTaskIdClosePostRequest
	return r
}

func (r ApiTaskItemsWorkstreamTaskIdClosePostRequest) Execute() (*TaskItemsWorkstreamTaskIdClosePost200Response, *http.Response, error) {
	return r.ApiService.TaskItemsWorkstreamTaskIdClosePostExecute(r)
}

/*
TaskItemsWorkstreamTaskIdClosePost Method for TaskItemsWorkstreamTaskIdClosePost

Submits the workstream task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workstreamTaskId Workstream Task id
 @return ApiTaskItemsWorkstreamTaskIdClosePostRequest
*/
func (a *TaskItemsAPIService) TaskItemsWorkstreamTaskIdClosePost(ctx context.Context, workstreamTaskId int64) ApiTaskItemsWorkstreamTaskIdClosePostRequest {
	return ApiTaskItemsWorkstreamTaskIdClosePostRequest{
		ApiService: a,
		ctx: ctx,
		workstreamTaskId: workstreamTaskId,
	}
}

// Execute executes the request
//  @return TaskItemsWorkstreamTaskIdClosePost200Response
func (a *TaskItemsAPIService) TaskItemsWorkstreamTaskIdClosePostExecute(r ApiTaskItemsWorkstreamTaskIdClosePostRequest) (*TaskItemsWorkstreamTaskIdClosePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskItemsWorkstreamTaskIdClosePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskItemsAPIService.TaskItemsWorkstreamTaskIdClosePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task_items/{workstream_task_id}/close"
	localVarPath = strings.Replace(localVarPath, "{"+"workstream_task_id"+"}", url.PathEscape(parameterValueToString(r.workstreamTaskId, "workstreamTaskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taskItemsWorkstreamTaskIdClosePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTaskItemsWorkstreamTaskIdSubmitPostRequest struct {
	ctx context.Context
	ApiService *TaskItemsAPIService
	workstreamTaskId int64
}

func (r ApiTaskItemsWorkstreamTaskIdSubmitPostRequest) Execute() (*TaskItemsSubmit, *http.Response, error) {
	return r.ApiService.TaskItemsWorkstreamTaskIdSubmitPostExecute(r)
}

/*
TaskItemsWorkstreamTaskIdSubmitPost Method for TaskItemsWorkstreamTaskIdSubmitPost

Submits the workstream task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workstreamTaskId Workstream Task id
 @return ApiTaskItemsWorkstreamTaskIdSubmitPostRequest
*/
func (a *TaskItemsAPIService) TaskItemsWorkstreamTaskIdSubmitPost(ctx context.Context, workstreamTaskId int64) ApiTaskItemsWorkstreamTaskIdSubmitPostRequest {
	return ApiTaskItemsWorkstreamTaskIdSubmitPostRequest{
		ApiService: a,
		ctx: ctx,
		workstreamTaskId: workstreamTaskId,
	}
}

// Execute executes the request
//  @return TaskItemsSubmit
func (a *TaskItemsAPIService) TaskItemsWorkstreamTaskIdSubmitPostExecute(r ApiTaskItemsWorkstreamTaskIdSubmitPostRequest) (*TaskItemsSubmit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskItemsSubmit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskItemsAPIService.TaskItemsWorkstreamTaskIdSubmitPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/task_items/{workstream_task_id}/submit"
	localVarPath = strings.Replace(localVarPath, "{"+"workstream_task_id"+"}", url.PathEscape(parameterValueToString(r.workstreamTaskId, "workstreamTaskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
