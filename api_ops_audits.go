/*
AuditBoard Developer Portal API Documentation

External API reference documentation.

API version: 23.8.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package auditboard

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// OpsAuditsAPIService OpsAuditsAPI service
type OpsAuditsAPIService service

type ApiOpsAuditsGetRequest struct {
	ctx context.Context
	ApiService *OpsAuditsAPIService
	include *[]string
}

// Possible sideloaded relationships
func (r ApiOpsAuditsGetRequest) Include(include []string) ApiOpsAuditsGetRequest {
	r.include = &include
	return r
}

func (r ApiOpsAuditsGetRequest) Execute() (*OpsAuditsGet200Response, *http.Response, error) {
	return r.ApiService.OpsAuditsGetExecute(r)
}

/*
OpsAuditsGet Method for OpsAuditsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOpsAuditsGetRequest
*/
func (a *OpsAuditsAPIService) OpsAuditsGet(ctx context.Context) ApiOpsAuditsGetRequest {
	return ApiOpsAuditsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OpsAuditsGet200Response
func (a *OpsAuditsAPIService) OpsAuditsGetExecute(r ApiOpsAuditsGetRequest) (*OpsAuditsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OpsAuditsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpsAuditsAPIService.OpsAuditsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ops_audits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOpsAuditsIdClonePostRequest struct {
	ctx context.Context
	ApiService *OpsAuditsAPIService
	id int64
	opsAuditsIdClonePostRequest *OpsAuditsIdClonePostRequest
}

func (r ApiOpsAuditsIdClonePostRequest) OpsAuditsIdClonePostRequest(opsAuditsIdClonePostRequest OpsAuditsIdClonePostRequest) ApiOpsAuditsIdClonePostRequest {
	r.opsAuditsIdClonePostRequest = &opsAuditsIdClonePostRequest
	return r
}

func (r ApiOpsAuditsIdClonePostRequest) Execute() (*OpsAuditsGet200Response, *http.Response, error) {
	return r.ApiService.OpsAuditsIdClonePostExecute(r)
}

/*
OpsAuditsIdClonePost Method for OpsAuditsIdClonePost

Create an OpsAudit using an existing OpsAudit template or an existing OpsAudit. The is_template field in the request body
			should be set to true or false depending on using an OpsAudit template or OpsAudit as the basis for the clone

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id will be either the id of the OpsAudit Template or the id of the OpsAudit to be     used as a basis for the clone.
 @return ApiOpsAuditsIdClonePostRequest
*/
func (a *OpsAuditsAPIService) OpsAuditsIdClonePost(ctx context.Context, id int64) ApiOpsAuditsIdClonePostRequest {
	return ApiOpsAuditsIdClonePostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return OpsAuditsGet200Response
func (a *OpsAuditsAPIService) OpsAuditsIdClonePostExecute(r ApiOpsAuditsIdClonePostRequest) (*OpsAuditsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OpsAuditsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpsAuditsAPIService.OpsAuditsIdClonePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ops_audits/{id}/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opsAuditsIdClonePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOpsAuditsOpsAuditIdCancelPutRequest struct {
	ctx context.Context
	ApiService *OpsAuditsAPIService
	opsAuditId int64
	opsAuditsOpsAuditIdCancelPutRequest *OpsAuditsOpsAuditIdCancelPutRequest
}

func (r ApiOpsAuditsOpsAuditIdCancelPutRequest) OpsAuditsOpsAuditIdCancelPutRequest(opsAuditsOpsAuditIdCancelPutRequest OpsAuditsOpsAuditIdCancelPutRequest) ApiOpsAuditsOpsAuditIdCancelPutRequest {
	r.opsAuditsOpsAuditIdCancelPutRequest = &opsAuditsOpsAuditIdCancelPutRequest
	return r
}

func (r ApiOpsAuditsOpsAuditIdCancelPutRequest) Execute() (*OpsAuditCancel, *http.Response, error) {
	return r.ApiService.OpsAuditsOpsAuditIdCancelPutExecute(r)
}

/*
OpsAuditsOpsAuditIdCancelPut Method for OpsAuditsOpsAuditIdCancelPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param opsAuditId OpsAudit id
 @return ApiOpsAuditsOpsAuditIdCancelPutRequest
*/
func (a *OpsAuditsAPIService) OpsAuditsOpsAuditIdCancelPut(ctx context.Context, opsAuditId int64) ApiOpsAuditsOpsAuditIdCancelPutRequest {
	return ApiOpsAuditsOpsAuditIdCancelPutRequest{
		ApiService: a,
		ctx: ctx,
		opsAuditId: opsAuditId,
	}
}

// Execute executes the request
//  @return OpsAuditCancel
func (a *OpsAuditsAPIService) OpsAuditsOpsAuditIdCancelPutExecute(r ApiOpsAuditsOpsAuditIdCancelPutRequest) (*OpsAuditCancel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OpsAuditCancel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpsAuditsAPIService.OpsAuditsOpsAuditIdCancelPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ops_audits/{ops_audit_id}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"ops_audit_id"+"}", url.PathEscape(parameterValueToString(r.opsAuditId, "opsAuditId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.opsAuditsOpsAuditIdCancelPutRequest == nil {
		return localVarReturnValue, nil, reportError("opsAuditsOpsAuditIdCancelPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opsAuditsOpsAuditIdCancelPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOpsAuditsOpsAuditIdDeleteRequest struct {
	ctx context.Context
	ApiService *OpsAuditsAPIService
	opsAuditId int64
}

func (r ApiOpsAuditsOpsAuditIdDeleteRequest) Execute() (*OpsAudits, *http.Response, error) {
	return r.ApiService.OpsAuditsOpsAuditIdDeleteExecute(r)
}

/*
OpsAuditsOpsAuditIdDelete Method for OpsAuditsOpsAuditIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param opsAuditId Model id
 @return ApiOpsAuditsOpsAuditIdDeleteRequest
*/
func (a *OpsAuditsAPIService) OpsAuditsOpsAuditIdDelete(ctx context.Context, opsAuditId int64) ApiOpsAuditsOpsAuditIdDeleteRequest {
	return ApiOpsAuditsOpsAuditIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		opsAuditId: opsAuditId,
	}
}

// Execute executes the request
//  @return OpsAudits
func (a *OpsAuditsAPIService) OpsAuditsOpsAuditIdDeleteExecute(r ApiOpsAuditsOpsAuditIdDeleteRequest) (*OpsAudits, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OpsAudits
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpsAuditsAPIService.OpsAuditsOpsAuditIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ops_audits/{ops_audit_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"ops_audit_id"+"}", url.PathEscape(parameterValueToString(r.opsAuditId, "opsAuditId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOpsAuditsOpsAuditIdExportAuditFormsPostRequest struct {
	ctx context.Context
	ApiService *OpsAuditsAPIService
	opsAuditId int64
}

func (r ApiOpsAuditsOpsAuditIdExportAuditFormsPostRequest) Execute() (*OpsAuditsOpsAuditIdExportAuditFormsPost200Response, *http.Response, error) {
	return r.ApiService.OpsAuditsOpsAuditIdExportAuditFormsPostExecute(r)
}

/*
OpsAuditsOpsAuditIdExportAuditFormsPost Method for OpsAuditsOpsAuditIdExportAuditFormsPost

Once the POST request is made, you must make a GET request to /api/v1/notification_messages to obtain the url
			to download the exported audit forms. The response of the GET request will contain an array of completed exports along with
			their respective download url's. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param opsAuditId The id of the ops_audit.
 @return ApiOpsAuditsOpsAuditIdExportAuditFormsPostRequest
*/
func (a *OpsAuditsAPIService) OpsAuditsOpsAuditIdExportAuditFormsPost(ctx context.Context, opsAuditId int64) ApiOpsAuditsOpsAuditIdExportAuditFormsPostRequest {
	return ApiOpsAuditsOpsAuditIdExportAuditFormsPostRequest{
		ApiService: a,
		ctx: ctx,
		opsAuditId: opsAuditId,
	}
}

// Execute executes the request
//  @return OpsAuditsOpsAuditIdExportAuditFormsPost200Response
func (a *OpsAuditsAPIService) OpsAuditsOpsAuditIdExportAuditFormsPostExecute(r ApiOpsAuditsOpsAuditIdExportAuditFormsPostRequest) (*OpsAuditsOpsAuditIdExportAuditFormsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OpsAuditsOpsAuditIdExportAuditFormsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpsAuditsAPIService.OpsAuditsOpsAuditIdExportAuditFormsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ops_audits/{ops_audit_id}/export_audit_forms"
	localVarPath = strings.Replace(localVarPath, "{"+"ops_audit_id"+"}", url.PathEscape(parameterValueToString(r.opsAuditId, "opsAuditId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOpsAuditsOpsAuditIdGetRequest struct {
	ctx context.Context
	ApiService *OpsAuditsAPIService
	opsAuditId int64
	include *[]string
}

// Possible sideloaded relationships
func (r ApiOpsAuditsOpsAuditIdGetRequest) Include(include []string) ApiOpsAuditsOpsAuditIdGetRequest {
	r.include = &include
	return r
}

func (r ApiOpsAuditsOpsAuditIdGetRequest) Execute() (*OpsAudits, *http.Response, error) {
	return r.ApiService.OpsAuditsOpsAuditIdGetExecute(r)
}

/*
OpsAuditsOpsAuditIdGet Method for OpsAuditsOpsAuditIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param opsAuditId Model id
 @return ApiOpsAuditsOpsAuditIdGetRequest
*/
func (a *OpsAuditsAPIService) OpsAuditsOpsAuditIdGet(ctx context.Context, opsAuditId int64) ApiOpsAuditsOpsAuditIdGetRequest {
	return ApiOpsAuditsOpsAuditIdGetRequest{
		ApiService: a,
		ctx: ctx,
		opsAuditId: opsAuditId,
	}
}

// Execute executes the request
//  @return OpsAudits
func (a *OpsAuditsAPIService) OpsAuditsOpsAuditIdGetExecute(r ApiOpsAuditsOpsAuditIdGetRequest) (*OpsAudits, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OpsAudits
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpsAuditsAPIService.OpsAuditsOpsAuditIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ops_audits/{ops_audit_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"ops_audit_id"+"}", url.PathEscape(parameterValueToString(r.opsAuditId, "opsAuditId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOpsAuditsOpsAuditIdMergePostRequest struct {
	ctx context.Context
	ApiService *OpsAuditsAPIService
	opsAuditId int64
	opsAuditsOpsAuditIdMergePostRequest *OpsAuditsOpsAuditIdMergePostRequest
}

func (r ApiOpsAuditsOpsAuditIdMergePostRequest) OpsAuditsOpsAuditIdMergePostRequest(opsAuditsOpsAuditIdMergePostRequest OpsAuditsOpsAuditIdMergePostRequest) ApiOpsAuditsOpsAuditIdMergePostRequest {
	r.opsAuditsOpsAuditIdMergePostRequest = &opsAuditsOpsAuditIdMergePostRequest
	return r
}

func (r ApiOpsAuditsOpsAuditIdMergePostRequest) Execute() (*OpsAuditsGet200Response, *http.Response, error) {
	return r.ApiService.OpsAuditsOpsAuditIdMergePostExecute(r)
}

/*
OpsAuditsOpsAuditIdMergePost Method for OpsAuditsOpsAuditIdMergePost

Imports a Workstep to the OpsAudit id specified in the path parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param opsAuditId The id of the OpsAudit that the Workstep will be imported to.
 @return ApiOpsAuditsOpsAuditIdMergePostRequest
*/
func (a *OpsAuditsAPIService) OpsAuditsOpsAuditIdMergePost(ctx context.Context, opsAuditId int64) ApiOpsAuditsOpsAuditIdMergePostRequest {
	return ApiOpsAuditsOpsAuditIdMergePostRequest{
		ApiService: a,
		ctx: ctx,
		opsAuditId: opsAuditId,
	}
}

// Execute executes the request
//  @return OpsAuditsGet200Response
func (a *OpsAuditsAPIService) OpsAuditsOpsAuditIdMergePostExecute(r ApiOpsAuditsOpsAuditIdMergePostRequest) (*OpsAuditsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OpsAuditsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpsAuditsAPIService.OpsAuditsOpsAuditIdMergePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ops_audits/{ops_audit_id}/merge"
	localVarPath = strings.Replace(localVarPath, "{"+"ops_audit_id"+"}", url.PathEscape(parameterValueToString(r.opsAuditId, "opsAuditId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opsAuditsOpsAuditIdMergePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOpsAuditsOpsAuditIdPutRequest struct {
	ctx context.Context
	ApiService *OpsAuditsAPIService
	opsAuditId int64
	opsAuditsPut *OpsAuditsPut
}

func (r ApiOpsAuditsOpsAuditIdPutRequest) OpsAuditsPut(opsAuditsPut OpsAuditsPut) ApiOpsAuditsOpsAuditIdPutRequest {
	r.opsAuditsPut = &opsAuditsPut
	return r
}

func (r ApiOpsAuditsOpsAuditIdPutRequest) Execute() (*OpsAudits, *http.Response, error) {
	return r.ApiService.OpsAuditsOpsAuditIdPutExecute(r)
}

/*
OpsAuditsOpsAuditIdPut Method for OpsAuditsOpsAuditIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param opsAuditId Model id
 @return ApiOpsAuditsOpsAuditIdPutRequest
*/
func (a *OpsAuditsAPIService) OpsAuditsOpsAuditIdPut(ctx context.Context, opsAuditId int64) ApiOpsAuditsOpsAuditIdPutRequest {
	return ApiOpsAuditsOpsAuditIdPutRequest{
		ApiService: a,
		ctx: ctx,
		opsAuditId: opsAuditId,
	}
}

// Execute executes the request
//  @return OpsAudits
func (a *OpsAuditsAPIService) OpsAuditsOpsAuditIdPutExecute(r ApiOpsAuditsOpsAuditIdPutRequest) (*OpsAudits, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OpsAudits
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpsAuditsAPIService.OpsAuditsOpsAuditIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ops_audits/{ops_audit_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"ops_audit_id"+"}", url.PathEscape(parameterValueToString(r.opsAuditId, "opsAuditId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opsAuditsPut
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOpsAuditsOpsAuditIdStartPutRequest struct {
	ctx context.Context
	ApiService *OpsAuditsAPIService
	opsAuditId int64
}

func (r ApiOpsAuditsOpsAuditIdStartPutRequest) Execute() (*OpsAuditStart, *http.Response, error) {
	return r.ApiService.OpsAuditsOpsAuditIdStartPutExecute(r)
}

/*
OpsAuditsOpsAuditIdStartPut Method for OpsAuditsOpsAuditIdStartPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param opsAuditId OpsAudit id
 @return ApiOpsAuditsOpsAuditIdStartPutRequest
*/
func (a *OpsAuditsAPIService) OpsAuditsOpsAuditIdStartPut(ctx context.Context, opsAuditId int64) ApiOpsAuditsOpsAuditIdStartPutRequest {
	return ApiOpsAuditsOpsAuditIdStartPutRequest{
		ApiService: a,
		ctx: ctx,
		opsAuditId: opsAuditId,
	}
}

// Execute executes the request
//  @return OpsAuditStart
func (a *OpsAuditsAPIService) OpsAuditsOpsAuditIdStartPutExecute(r ApiOpsAuditsOpsAuditIdStartPutRequest) (*OpsAuditStart, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OpsAuditStart
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpsAuditsAPIService.OpsAuditsOpsAuditIdStartPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ops_audits/{ops_audit_id}/start"
	localVarPath = strings.Replace(localVarPath, "{"+"ops_audit_id"+"}", url.PathEscape(parameterValueToString(r.opsAuditId, "opsAuditId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOpsAuditsPostRequest struct {
	ctx context.Context
	ApiService *OpsAuditsAPIService
	opsAuditsPostRequest *OpsAuditsPostRequest
}

func (r ApiOpsAuditsPostRequest) OpsAuditsPostRequest(opsAuditsPostRequest OpsAuditsPostRequest) ApiOpsAuditsPostRequest {
	r.opsAuditsPostRequest = &opsAuditsPostRequest
	return r
}

func (r ApiOpsAuditsPostRequest) Execute() (*OpsAuditsGet200Response, *http.Response, error) {
	return r.ApiService.OpsAuditsPostExecute(r)
}

/*
OpsAuditsPost Method for OpsAuditsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOpsAuditsPostRequest
*/
func (a *OpsAuditsAPIService) OpsAuditsPost(ctx context.Context) ApiOpsAuditsPostRequest {
	return ApiOpsAuditsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OpsAuditsGet200Response
func (a *OpsAuditsAPIService) OpsAuditsPostExecute(r ApiOpsAuditsPostRequest) (*OpsAuditsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OpsAuditsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpsAuditsAPIService.OpsAuditsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ops_audits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opsAuditsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
